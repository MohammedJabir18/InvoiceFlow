pub mod template;

use anyhow::{Context, Result};
use std::path::PathBuf;
use std::fs;
use std::process::Command;

#[cfg(windows)]
use std::os::windows::process::CommandExt;

pub struct PdfGenerator {
    output_dir: PathBuf,
}

impl PdfGenerator {
    pub fn new(output_dir: PathBuf) -> Self {
        fs::create_dir_all(&output_dir).ok();
        Self { output_dir }
    }

    /// Generates a PDF using system-installed Edge/Chrome in headless mode.
    /// Uses a persistent user-data-dir to avoid slow cold-start profile creation.
    pub fn generate_from_url(&self, url: &str, output_filename: &str) -> Result<PathBuf> {
        let output_path = self.output_dir.join(output_filename);
        
        // Find a suitable browser executable
        let browser_paths = [
            // ms edge is guaranteed on win10/11
            r#"C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe"#,
            r#"C:\Program Files\Microsoft\Edge\Application\msedge.exe"#,
            r#"C:\Program Files\Google\Chrome\Application\chrome.exe"#,
            r#"C:\Program Files (x86)\Google\Chrome\Application\chrome.exe"#,
        ];

        let mut exe_path = "";
        for path in browser_paths {
            if std::path::Path::new(path).exists() {
                exe_path = path;
                break;
            }
        }

        if exe_path.is_empty() {
            return Err(anyhow::anyhow!("No supported browser (Edge/Chrome) found for PDF generation"));
        }

        // Use a persistent user-data-dir so the browser reuses its cached profile
        // instead of creating a fresh temporary one every time (~2-3s saved)
        let pdf_profile_dir = std::env::temp_dir().join("invoiceflow_pdf_profile");
        fs::create_dir_all(&pdf_profile_dir).ok();

        let mut cmd = Command::new(exe_path);
        
        #[cfg(windows)]
        {
            const CREATE_NO_WINDOW: u32 = 0x08000000;
            cmd.creation_flags(CREATE_NO_WINDOW);
        }

        let status = cmd
            .args([
                "--headless=new",
                "--disable-gpu",
                "--no-sandbox",
                "--no-pdf-header-footer",
                "--disable-software-rasterizer",
                "--run-all-compositor-stages-before-draw",
                // Performance flags to minimize startup time
                "--disable-extensions",
                "--disable-background-networking",
                "--disable-sync",
                "--disable-default-apps",
                "--no-first-run",
                "--disable-features=TranslateUI",
                "--disable-component-update",
                "--disable-hang-monitor",
                "--disable-prompt-on-repost",
                "--disable-domain-reliability",
                "--disable-client-side-phishing-detection",
                "--disable-breakpad",
                // Reuse a persistent profile directory for faster startup
                &format!("--user-data-dir={}", pdf_profile_dir.display()),
                // Virtual time budget so the page doesn't wait for real timers
                "--virtual-time-budget=5000",
                &format!("--print-to-pdf={}", output_path.display()),
                url,
            ])
            .status()
            .context("Failed to execute browser process for PDF generation")?;

        if !status.success() {
            return Err(anyhow::anyhow!("Browser process failed with status: {}", status));
        }

        if !output_path.exists() {
            return Err(anyhow::anyhow!("PDF file was not created at expected path"));
        }

        Ok(output_path)
    }

    pub fn generate_from_html(&self, html: &str, output_filename: &str) -> Result<PathBuf> {
        let temp_dir = std::env::temp_dir();
        let timestamp = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_micros();
        let temp_html_path = temp_dir.join(format!("invoice_flow_{}.html", timestamp));
        
        fs::write(&temp_html_path, html).context("Failed to write temporary HTML file")?;
        
        let url = format!("file:///{}", temp_html_path.to_string_lossy().replace("\\", "/"));
        
        let result = self.generate_from_url(&url, output_filename);
        
        let _ = fs::remove_file(temp_html_path);
        
        result
    }

    pub fn generate_invoice_pdf(&self, invoice_id: &str) -> Result<PathBuf> {
        let url = format!("data:text/html,<h1>Invoice {}</h1><p>Generated by InvoiceFlow</p>", invoice_id); 
        self.generate_from_url(&url, &format!("invoice-{}.pdf", invoice_id))
    }
}
